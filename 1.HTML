const express = require('express');
const cors = require('cors');
const mysql = require('mysql2/promise');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const nodemailer = require('nodemailer');
const { google } = require('googleapis');
const path = require('path');
const multer = require('multer');
const fs = require('fs');
require('dotenv').config();

const app = express();

// Environment Variables
const requiredEnvVars = ['DB_NAME', 'DB_HOST', 'DB_USER', 'DB_PASSWORD', 'DB_PORT', 'JWT_SECRET', 'GOOGLE_CLIENT_ID', 'GOOGLE_CLIENT_SECRET', 'EMAIL_USER', 'EMAIL_PASS'];
for (const envVar of requiredEnvVars) {
  if (!process.env[envVar]) {
    console.error(`Missing environment variable: ${envVar}`);
    process.exit(1);
  }
}

const {
  DB_NAME,
  DB_HOST,
  DB_USER,
  DB_PASSWORD,
  DB_PORT,
  JWT_SECRET,
  GOOGLE_CLIENT_ID,
  GOOGLE_CLIENT_SECRET,
  EMAIL_USER,
  EMAIL_PASS,
  PORT = 3000,
  CLIENT_URL = 'http://localhost:3000',
  BASE_URL = process.env.NODE_ENV === 'production' ? 'https://delicute.onrender.com' : 'http://localhost:3000'
} = process.env;

// Middleware
app.use(cors({
  origin: ['https://delicute.onrender.com', 'http://localhost:3000'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));
app.use(express.json());

// Serve static files
const publicPath = path.join(__dirname, 'public');
const uploadDir = path.join(publicPath, 'uploads');
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
}
app.use('/uploads', express.static(uploadDir, {
  setHeaders: (res) => {
    res.set('Cache-Control', 'public, max-age=31536000');
    res.set('Access-Control-Allow-Origin', '*');
  }
}));
app.use(express.static(publicPath));

// File Upload Setup
const storage = multer.diskStorage({
  destination: (req, file, cb) => cb(null, uploadDir),
  filename: (req, file, cb) => {
    const sanitizedFilename = file.originalname.replace(/[^a-zA-Z0-9.-]/g, '_');
    cb(null, `${Date.now()}-${sanitizedFilename}`);
  }
});
const upload = multer({
  storage,
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Only image files allowed'), false);
    }
  },
  limits: { fileSize: 5 * 1024 * 1024 }
});

// Database Connection
const pool = mysql.createPool({
  host: DB_HOST,
  user: DB_USER,
  password: DB_PASSWORD,
  database: DB_NAME,
  port: DB_PORT,
  connectionLimit: 10
});

// Initialize Database
async function initializeDatabase() {
  try {
    const connection = await pool.getConnection();
    await connection.query(`
      CREATE TABLE IF NOT EXISTS users (
        id INT AUTO_INCREMENT PRIMARY KEY,
        name VARCHAR(255),
        email VARCHAR(255) UNIQUE NOT NULL,
        phone VARCHAR(20),
        password VARCHAR(255),
        is_admin BOOLEAN DEFAULT FALSE,
        is_blocked BOOLEAN DEFAULT FALSE,
        reset_otp VARCHAR(6),
        profile_image VARCHAR(255),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    await connection.query(`
      CREATE TABLE IF NOT EXISTS menu_items (
        id INT AUTO_INCREMENT PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        category VARCHAR(100) NOT NULL,
        price DECIMAL(10,2) NOT NULL,
        description TEXT,
        image VARCHAR(255),
        rating INT DEFAULT 0,
        rating_count INT DEFAULT 0,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    await connection.query(`
      CREATE TABLE IF NOT EXISTS favorites (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        menu_item_id INT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
        FOREIGN KEY (menu_item_id) REFERENCES menu_items(id) ON DELETE CASCADE,
        UNIQUE (user_id, menu_item_id)
      )
    `);
    await connection.query(`
      CREATE TABLE IF NOT EXISTS offers (
        id INT AUTO_INCREMENT PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        description TEXT,
        price DECIMAL(10,2) NOT NULL,
        image VARCHAR(255),
        is_special BOOLEAN DEFAULT FALSE,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    await connection.query(`
      CREATE TABLE IF NOT EXISTS coupons (
        id INT AUTO_INCREMENT PRIMARY KEY,
        code VARCHAR(50) UNIQUE NOT NULL,
        discount INT NOT NULL,
        description TEXT,
        image VARCHAR(255),
        item_category VARCHAR(100),
        min_quantity INT,
        is_special BOOLEAN DEFAULT FALSE,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    await connection.query(`
      CREATE TABLE IF NOT EXISTS contact_messages (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT,
        name VARCHAR(255) NOT NULL,
        email VARCHAR(255) NOT NULL,
        subject VARCHAR(255) NOT NULL,
        message TEXT NOT NULL,
        status VARCHAR(50) DEFAULT 'Pending',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
      )
    `);
    await connection.query(`
      CREATE TABLE IF NOT EXISTS addresses (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        full_name VARCHAR(255) NOT NULL,
        mobile_number VARCHAR(20) NOT NULL,
        house_flat_no VARCHAR(100) NOT NULL,
        floor_no VARCHAR(50),
        address TEXT NOT NULL,
        landmark VARCHAR(255),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
      )
    `);
    await connection.query(`
      CREATE TABLE IF NOT EXISTS orders (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT,
        address_id INT,
        items JSON NOT NULL,
        total DECIMAL(10,2) NOT NULL,
        status VARCHAR(50) DEFAULT 'Pending',
        payment_status VARCHAR(50) DEFAULT 'Pending',
        payment_method VARCHAR(50),
        coupon VARCHAR(50),
        discount DECIMAL(10,2) DEFAULT 0,
        estimated_delivery DATETIME,
        cancellation_reason TEXT,
        order_id VARCHAR(50) UNIQUE NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL,
        FOREIGN KEY (address_id) REFERENCES addresses(id) ON DELETE SET NULL
      )
    `);
    await connection.query(`
      CREATE TABLE IF NOT EXISTS ratings (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT,
        menu_item_id INT,
        rating INT NOT NULL,
        review TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL,
        FOREIGN KEY (menu_item_id) REFERENCES menu_items(id) ON DELETE CASCADE
      )
    `);
    await connection.query(`
      CREATE TABLE IF NOT EXISTS restaurant_status (
        id INT PRIMARY KEY,
        is_open BOOLEAN DEFAULT TRUE,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    await connection.query('INSERT IGNORE INTO restaurant_status (id, is_open) VALUES (1, TRUE)');
    console.log('✅ Database initialized');
    connection.release();
  } catch (error) {
    console.error('❌ Database initialization failed:', error.stack);
    throw error;
  }
}

// Email Transporter
const transporter = nodemailer.createTransport({
  host: 'smtp.gmail.com',
  port: 587,
  secure: false,
  auth: { user: EMAIL_USER, pass: EMAIL_PASS }
});

// Google OAuth
const oauth2Client = new google.auth.OAuth2(GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, `${BASE_URL}/api/auth/google/callback`);

// JWT Middleware
function authenticateToken(req, res, next) {
  const token = req.headers['authorization']?.split(' ')[1];
  if (!token) return res.status(401).json({ error: 'No token provided' });
  try {
    req.user = jwt.verify(token, JWT_SECRET);
    next();
  } catch (error) {
    console.error('Invalid token:', error.message);
    res.status(403).json({ error: 'Invalid token' });
  }
}

function requireAdmin(req, res, next) {
  if (!req.user.isAdmin) return res.status(403).json({ error: 'Admin access required' });
  next();
}

// Helper Functions
function getImageUrl(imagePath) {
  if (!imagePath || typeof imagePath !== 'string') return null;
  if (imagePath.startsWith('http')) return imagePath;
  return `${BASE_URL}/uploads/${imagePath.split('/').pop()}`;
}

function validateInput(data, requiredFields) {
  for (const field of requiredFields) {
    if (!data[field] || (typeof data[field] === 'string' && !data[field].trim())) {
      return { valid: false, error: `${field.replace(/_/g, ' ')} is required` };
    }
  }
  return { valid: true };
}

function sanitizeHTML(str) {
  if (!str) return '';
  return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// Routes
app.get('/', (req, res) => res.sendFile(path.join(publicPath, 'index.html')));
app.get('/admin', (req, res) => res.sendFile(path.join(publicPath, 'admin.html')));

// File Upload Endpoint
app.post('/api/files/upload', authenticateToken, upload.single('file'), (req, res) => {
  if (!req.file) {
    console.error('File upload failed: No file or invalid type');
    return res.status(400).json({ error: 'No file uploaded or invalid file type' });
  }
  const fileUrl = getImageUrl(req.file.filename);
  console.log(`File uploaded: ${fileUrl}`);
  res.json({ fileUrl });
});

// Auth Routes
app.get('/api/auth/me', authenticateToken, async (req, res) => {
  try {
    const [result] = await pool.query('SELECT id, email, name, phone, is_admin, profile_image FROM users WHERE id = ?', [req.user.id]);
    if (!result[0]) return res.status(404).json({ error: 'User not found' });
    res.json({
      _id: result[0].id,
      email: result[0].email,
      name: result[0].name,
      phone: result[0].phone,
      isAdmin: !!result[0].is_admin,
      profileImage: getImageUrl(result[0].profile_image)
    });
  } catch (error) {
    console.error('Error fetching user:', error.stack);
    res.status(500).json({ error: 'Failed to fetch user' });
  }
});

app.put('/api/auth/update', authenticateToken, upload.single('profileImage'), async (req, res) => {
  const { name, email, phone } = req.body;
  try {
    let profileImage = null;
    if (req.file) {
      profileImage = `/uploads/${req.file.filename}`;
      console.log(`Profile image uploaded: ${profileImage}`);
    } else {
      const [currentUser] = await pool.query('SELECT profile_image FROM users WHERE id = ?', [req.user.id]);
      profileImage = currentUser[0]?.profile_image || null;
    }

    const finalName = name && typeof name === 'string' && name.trim() ? name.trim() : null;
    const finalPhone = phone && typeof phone === 'string' && phone.trim() ? phone.trim() : null;
    let finalEmail = null;
    if (email && typeof email === 'string' && email.trim()) {
      finalEmail = email.trim();
      if (!/^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/.test(finalEmail)) {
        return res.status(400).json({ error: 'Invalid email format' });
      }
    }

    if (finalPhone && !/^\d{10}$/.test(finalPhone)) {
      return res.status(400).json({ error: 'Phone number must be 10 digits' });
    }

    const [currentUser] = await pool.query('SELECT email FROM users WHERE id = ?', [req.user.id]);
    const emailToUse = finalEmail || currentUser[0].email;

    await pool.query(
      'UPDATE users SET name = COALESCE(?, name), email = ?, phone = COALESCE(?, phone), profile_image = COALESCE(?, profile_image) WHERE id = ?',
      [finalName, emailToUse, finalPhone, profileImage, req.user.id]
    );

    const [updatedUser] = await pool.query('SELECT id, name, email, phone, is_admin, profile_image FROM users WHERE id = ?', [req.user.id]);
    res.json({
      _id: updatedUser[0].id,
      name: updatedUser[0].name,
      email: updatedUser[0].email,
      phone: updatedUser[0].phone,
      isAdmin: !!updatedUser[0].is_admin,
      profileImage: getImageUrl(updatedUser[0].profile_image),
      message: 'Profile updated successfully'
    });
  } catch (error) {
    console.error('Error updating profile:', error.stack);
    res.status(500).json({ error: 'Failed to update profile' });
  }
});

app.get('/api/auth/admin/me', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const [result] = await pool.query('SELECT id, email, name, phone, is_admin, profile_image FROM users WHERE id = ?', [req.user.id]);
    if (!result[0]) return res.status(404).json({ error: 'Admin not found' });
    res.json({
      _id: result[0].id,
      email: result[0].email,
      name: result[0].name,
      phone: result[0].phone,
      isAdmin: !!result[0].is_admin,
      profileImage: getImageUrl(result[0].profile_image)
    });
  } catch (error) {
    console.error('Error fetching admin:', error.stack);
    res.status(500).json({ error: 'Failed to fetch admin' });
  }
});

// Favorites Routes
app.get('/api/favorites', authenticateToken, async (req, res) => {
  try {
    const [favorites] = await pool.query(`
      SELECT f.id, f.menu_item_id, m.name, m.category, m.price, m.description, m.image, m.rating
      FROM favorites f
      JOIN menu_items m ON f.menu_item_id = m.id
      WHERE f.user_id = ?
    `, [req.user.id]);
    res.json(favorites.map(fav => ({
      _id: fav.id,
      menuItemId: fav.menu_item_id,
      name: fav.name,
      category: fav.category,
      price: parseFloat(fav.price),
      description: fav.description,
      image: getImageUrl(fav.image),
      rating: fav.rating
    })));
  } catch (error) {
    console.error('Error fetching favorites:', error.stack);
    res.status(500).json({ error: 'Failed to fetch favorites' });
  }
});

app.post('/api/favorites', authenticateToken, async (req, res) => {
  const { menuItemId } = req.body;
  if (!menuItemId) return res.status(400).json({ error: 'Menu item ID required' });
  try {
    const [menuItem] = await pool.query('SELECT id FROM menu_items WHERE id = ?', [menuItemId]);
    if (!menuItem[0]) return res.status(404).json({ error: 'Menu item not found' });
    await pool.query('INSERT INTO favorites (user_id, menu_item_id) VALUES (?, ?)', [req.user.id, menuItemId]);
    const [newFavorite] = await pool.query(`
      SELECT f.id, f.menu_item_id, m.name, m.category, m.price, m.description, m.image, m.rating
      FROM favorites f
      JOIN menu_items m ON f.menu_item_id = m.id
      WHERE f.user_id = ? AND f.menu_item_id = ?
    `, [req.user.id, menuItemId]);
    res.status(201).json({
      _id: newFavorite[0].id,
      menuItemId: newFavorite[0].menu_item_id,
      name: newFavorite[0].name,
      category: newFavorite[0].category,
      price: parseFloat(newFavorite[0].price),
      description: newFavorite[0].description,
      image: getImageUrl(newFavorite[0].image),
      rating: newFavorite[0].rating
    });
  } catch (error) {
    if (error.code === 'ER_DUP_ENTRY') {
      return res.status(400).json({ error: 'Item already in favorites' });
    }
    console.error('Error adding favorite:', error.stack);
    res.status(500).json({ error: 'Failed to add favorite' });
  }
});

app.delete('/api/favorites/:menuItemId', authenticateToken, async (req, res) => {
  try {
    const [result] = await pool.query('DELETE FROM favorites WHERE user_id = ? AND menu_item_id = ?', [req.user.id, req.params.menuItemId]);
    if (result.affectedRows === 0) return res.status(404).json({ error: 'Favorite not found' });
    res.json({ message: 'Favorite removed successfully' });
  } catch (error) {
    console.error('Error removing favorite:', error.stack);
    res.status(500).json({ error: 'Failed to remove favorite' });
  }
});

// Menu Routes
app.get('/api/menu', async (req, res) => {
  try {
    const [result] = await pool.query('SELECT * FROM menu_items ORDER BY created_at DESC');
    res.json(result.map(item => ({
      _id: item.id,
      name: item.name,
      category: item.category,
      price: parseFloat(item.price),
      description: item.description,
      image: getImageUrl(item.image),
      rating: item.rating,
      created_at: item.created_at
    })));
  } catch (error) {
    console.error('Error fetching menu:', error.stack);
    res.status(500).json({ error: 'Failed to fetch menu' });
  }
});

app.get('/api/menu/categories', async (req, res) => {
  try {
    const [result] = await pool.query('SELECT DISTINCT category FROM menu_items ORDER BY category');
    res.json(result.map(row => row.category));
  } catch (error) {
    console.error('Error fetching categories:', error.stack);
    res.status(500).json({ error: 'Failed to fetch categories' });
  }
});

app.get('/api/menu/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const [result] = await pool.query('SELECT * FROM menu_items WHERE id = ?', [req.params.id]);
    if (!result[0]) return res.status(404).json({ error: 'Menu item not found' });
    res.json({
      _id: result[0].id,
      name: result[0].name,
      category: result[0].category,
      price: parseFloat(result[0].price),
      description: result[0].description,
      image: getImageUrl(result[0].image),
      rating: result[0].rating
    });
  } catch (error) {
    console.error('Error fetching menu item:', error.stack);
    res.status(500).json({ error: 'Failed to fetch menu item' });
  }
});

app.post('/api/menu', authenticateToken, requireAdmin, upload.single('image'), async (req, res) => {
  const { name, category, price, description } = req.body;
  const validation = validateInput({ name, category, price }, ['name', 'category', 'price']);
  if (!validation.valid) return res.status(400).json({ error: validation.error });
  try {
    let imageUrl = null;
    if (req.file) {
      imageUrl = `/uploads/${req.file.filename}`;
      console.log(`Menu item image uploaded: ${imageUrl}`);
    }
    const [result] = await pool.query('INSERT INTO menu_items (name, category, price, description, image) VALUES (?, ?, ?, ?, ?)', [name, category, parseFloat(price), description || null, imageUrl]);
    const [newItem] = await pool.query('SELECT * FROM menu_items WHERE id = ?', [result.insertId]);
    res.status(201).json({
      _id: newItem[0].id,
      name: newItem[0].name,
      category: newItem[0].category,
      price: parseFloat(newItem[0].price),
      description: newItem[0].description,
      image: getImageUrl(newItem[0].image)
    });
  } catch (error) {
    console.error('Error adding menu item:', error.stack);
    res.status(500).json({ error: 'Failed to add menu item' });
  }
});

app.put('/api/menu/:id', authenticateToken, requireAdmin, upload.single('image'), async (req, res) => {
  const { name, category, price, description } = req.body;
  const validation = validateInput({ name, category, price }, ['name', 'category', 'price']);
  if (!validation.valid) return res.status(400).json({ error: validation.error });
  try {
    let imageUrl = null;
    if (req.file) {
      imageUrl = `/uploads/${req.file.filename}`;
      console.log(`Menu item image updated: ${imageUrl}`);
    } else {
      const [currentItem] = await pool.query('SELECT image FROM menu_items WHERE id = ?', [req.params.id]);
      imageUrl = currentItem[0]?.image || null;
    }
    await pool.query('UPDATE menu_items SET name = ?, category = ?, price = ?, description = ?, image = ? WHERE id = ?', [name, category, parseFloat(price), description || null, imageUrl, req.params.id]);
    const [updatedItem] = await pool.query('SELECT * FROM menu_items WHERE id = ?', [req.params.id]);
    if (!updatedItem[0]) return res.status(404).json({ error: 'Menu item not found' });
    res.json({
      _id: updatedItem[0].id,
      name: updatedItem[0].name,
      category: updatedItem[0].category,
      price: parseFloat(updatedItem[0].price),
      description: updatedItem[0].description,
      image: getImageUrl(updatedItem[0].image)
    });
  } catch (error) {
    console.error('Error updating menu item:', error.stack);
    res.status(500).json({ error: 'Failed to update menu item' });
  }
});

app.delete('/api/menu/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const [result] = await pool.query('DELETE FROM menu_items WHERE id = ?', [req.params.id]);
    if (result.affectedRows === 0) return res.status(404).json({ error: 'Menu item not found' });
    res.json({ message: 'Menu item deleted' });
  } catch (error) {
    console.error('Error deleting menu item:', error.stack);
    res.status(500).json({ error: 'Failed to delete menu item' });
  }
});

app.post('/api/menu/:id/rate', authenticateToken, async (req, res) => {
  const { rating, review } = req.body;
  if (!rating || rating < 1 || rating > 5) return res.status(400).json({ error: 'Valid rating (1-5) required' });
  try {
    const [item] = await pool.query('SELECT id FROM menu_items WHERE id = ?', [req.params.id]);
    if (!item[0]) return res.status(404).json({ error: 'Menu item not found' });
    await pool.query('INSERT INTO ratings (user_id, menu_item_id, rating, review) VALUES (?, ?, ?, ?)', [req.user.id, req.params.id, rating, review || null]);
    const [ratings] = await pool.query('SELECT AVG(rating) as avg_rating, COUNT(*) as count FROM ratings WHERE menu_item_id = ?', [req.params.id]);
    const avgRating = Math.round(ratings[0].avg_rating);
    await pool.query('UPDATE menu_items SET rating = ?, rating_count = ? WHERE id = ?', [avgRating, ratings[0].count, req.params.id]);
    res.json({ message: 'Rating submitted. Thank you!' });
  } catch (error) {
    console.error('Error submitting rating:', error.stack);
    res.status(500).json({ error: 'Failed to submit rating' });
  }
});

// Offer Routes
app.get('/api/offers', async (req, res) => {
  try {
    const [result] = await pool.query('SELECT * FROM offers WHERE is_special = ? ORDER BY created_at DESC', [true]);
    res.json(result.map(offer => ({
      _id: offer.id,
      name: offer.name,
      price: parseFloat(offer.price),
      description: offer.description,
      image: getImageUrl(offer.image),
      isSpecial: offer.is_special,
      created_at: offer.created_at
    })));
  } catch (error) {
    console.error('Error fetching offers:', error.stack);
    res.status(500).json({ error: 'Failed to fetch offers' });
  }
});

app.get('/api/offers/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const [result] = await pool.query('SELECT * FROM offers WHERE id = ?', [req.params.id]);
    if (!result[0]) return res.status(404).json({ error: 'Offer not found' });
    res.json({
      _id: result[0].id,
      name: result[0].name,
      price: parseFloat(result[0].price),
      description: result[0].description,
      image: getImageUrl(result[0].image),
      isSpecial: result[0].is_special
    });
  } catch (error) {
    console.error('Error fetching offer:', error.stack);
    res.status(500).json({ error: 'Failed to fetch offer' });
  }
});

app.post('/api/offers', authenticateToken, requireAdmin, upload.single('image'), async (req, res) => {
  const { name, price, description, isSpecial } = req.body;
  const validation = validateInput({ name, price }, ['name', 'price']);
  if (!validation.valid) return res.status(400).json({ error: validation.error });
  try {
    let imageUrl = null;
    if (req.file) {
      imageUrl = `/uploads/${req.file.filename}`;
      console.log(`Offer image uploaded: ${imageUrl}`);
    }
    const [result] = await pool.query('INSERT INTO offers (name, price, description, image, is_special) VALUES (?, ?, ?, ?, ?)', [name, parseFloat(price), description || null, imageUrl, isSpecial === 'true']);
    const [newOffer] = await pool.query('SELECT * FROM offers WHERE id = ?', [result.insertId]);
    res.status(201).json({
      _id: newOffer[0].id,
      name: newOffer[0].name,
      price: parseFloat(newOffer[0].price),
      description: newOffer[0].description,
      image: getImageUrl(newOffer[0].image),
      isSpecial: newOffer[0].is_special
    });
  } catch (error) {
    console.error('Error adding offer:', error.stack);
    res.status(500).json({ error: 'Failed to add offer' });
  }
});

app.put('/api/offers/:id', authenticateToken, requireAdmin, upload.single('image'), async (req, res) => {
  const { name, price, description, isSpecial } = req.body;
  const validation = validateInput({ name, price }, ['name', 'price']);
  if (!validation.valid) return res.status(400).json({ error: validation.error });
  try {
    let imageUrl = null;
    if (req.file) {
      imageUrl = `/uploads/${req.file.filename}`;
      console.log(`Offer image updated: ${imageUrl}`);
    } else {
      const [currentOffer] = await pool.query('SELECT image FROM offers WHERE id = ?', [req.params.id]);
      imageUrl = currentOffer[0]?.image || null;
    }
    await pool.query(
      'UPDATE offers SET name = ?, price = ?, description = ?, image = ?, is_special = ? WHERE id = ?',
      [name, parseFloat(price), description || null, imageUrl, isSpecial === 'true', req.params.id]
    );
    const [updatedOffer] = await pool.query('SELECT * FROM offers WHERE id = ?', [req.params.id]);
    if (!updatedOffer[0]) return res.status(404).json({ error: 'Offer not found' });
    res.json({
      _id: updatedOffer[0].id,
      name: updatedOffer[0].name,
      price: parseFloat(updatedOffer[0].price),
      description: updatedOffer[0].description,
      image: getImageUrl(updatedOffer[0].image),
      isSpecial: updatedOffer[0].is_special
    });
  } catch (error) {
    console.error('Error updating offer:', error.stack);
    res.status(500).json({ error: 'Failed to update offer' });
  }
});

app.delete('/api/offers/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const [result] = await pool.query('DELETE FROM offers WHERE id = ?', [req.params.id]);
    if (result.affectedRows === 0) return res.status(404).json({ error: 'Offer not found' });
    res.json({ message: 'Offer deleted' });
  } catch (error) {
    console.error('Error deleting offer:', error.stack);
    res.status(500).json({ error: 'Failed to delete offer' });
  }
});

// Coupon Routes
app.get('/api/coupons', authenticateToken, async (req, res) => {
  try {
    const [result] = await pool.query('SELECT * FROM coupons ORDER BY created_at DESC');
    res.json(result.map(coupon => ({
      _id: coupon.id,
      code: coupon.code,
      discount: parseInt(coupon.discount),
      description: coupon.description,
      image: getImageUrl(coupon.image),
      itemCategory: coupon.item_category,
      minQuantity: parseInt(coupon.min_quantity) || null,
      isSpecial: coupon.is_special,
      created_at: coupon.created_at
    })));
  } catch (error) {
    console.error('Error fetching coupons:', error.stack);
    res.status(500).json({ error: 'Failed to fetch coupons' });
  }
});

app.get('/api/coupons/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const [result] = await pool.query('SELECT * FROM coupons WHERE id = ?', [req.params.id]);
    if (!result[0]) return res.status(404).json({ error: 'Coupon not found' });
    res.json({
      _id: result[0].id,
      code: result[0].code,
      discount: parseInt(result[0].discount),
      description: result[0].description,
      image: getImageUrl(result[0].image),
      itemCategory: result[0].item_category,
      minQuantity: parseInt(result[0].min_quantity) || null,
      isSpecial: result[0].is_special
    });
  } catch (error) {
    console.error('Error fetching coupon:', error.stack);
    res.status(500).json({ error: 'Failed to fetch coupon' });
  }
});

app.post('/api/coupons', authenticateToken, requireAdmin, upload.single('image'), async (req, res) => {
  const { code, discount, description, itemCategory, minQuantity, isSpecial } = req.body;
  const validation = validateInput({ code, discount }, ['code', 'discount']);
  if (!validation.valid) return res.status(400).json({ error: validation.error });

  const discountValue = parseInt(discount);
  if (isNaN(discountValue) || discountValue <= 0) {
    return res.status(400).json({ error: 'Discount must be a positive number' });
  }

  const minQuantityValue = minQuantity ? parseInt(minQuantity) : null;
  if (minQuantity && (isNaN(minQuantityValue) || minQuantityValue < 0)) {
    return res.status(400).json({ error: 'Minimum quantity must be a non-negative number' });
  }

  try {
    let imageUrl = null;
    if (req.file) {
      imageUrl = `/uploads/${req.file.filename}`;
      console.log(`Coupon image uploaded: ${imageUrl}`);
    }
    const [result] = await pool.query(
      'INSERT INTO coupons (code, discount, description, image, item_category, min_quantity, is_special) VALUES (?, ?, ?, ?, ?, ?, ?)',
      [code, discountValue, description || null, imageUrl, itemCategory || null, minQuantityValue, isSpecial === 'true']
    );
    const [newCoupon] = await pool.query('SELECT * FROM coupons WHERE id = ?', [result.insertId]);
    res.status(201).json({
      _id: newCoupon[0].id,
      code: newCoupon[0].code,
      discount: parseInt(newCoupon[0].discount),
      description: newCoupon[0].description,
      image: getImageUrl(newCoupon[0].image),
      itemCategory: newCoupon[0].item_category,
      minQuantity: parseInt(newCoupon[0].min_quantity) || null,
      isSpecial: newCoupon[0].is_special
    });
  } catch (error) {
    console.error('Error adding coupon:', error.stack);
    res.status(500).json({ error: 'Failed to add coupon' });
  }
});

app.put('/api/coupons/:id', authenticateToken, requireAdmin, upload.single('image'), async (req, res) => {
  const { code, discount, description, itemCategory, minQuantity, isSpecial } = req.body;
  const validation = validateInput({ code, discount }, ['code', 'discount']);
  if (!validation.valid) return res.status(400).json({ error: validation.error });

  const discountValue = parseInt(discount);
  if (isNaN(discountValue) || discountValue <= 0) {
    return res.status(400).json({ error: 'Discount must be a positive number' });
  }

  const minQuantityValue = minQuantity ? parseInt(minQuantity) : null;
  if (minQuantity && (isNaN(minQuantityValue) || minQuantityValue < 0)) {
    return res.status(400).json({ error: 'Minimum quantity must be a non-negative number' });
  }

  try {
    let imageUrl = null;
    if (req.file) {
      imageUrl = `/uploads/${req.file.filename}`;
      console.log(`Coupon image updated: ${imageUrl}`);
    } else {
      const [currentCoupon] = await pool.query('SELECT image FROM coupons WHERE id = ?', [req.params.id]);
      imageUrl = currentCoupon[0]?.image || null;
    }
    await pool.query(
      'UPDATE coupons SET code = ?, discount = ?, description = ?, image = ?, item_category = ?, min_quantity = ?, is_special = ? WHERE id = ?',
      [code, discountValue, description || null, imageUrl, itemCategory || null, minQuantityValue, isSpecial === 'true', req.params.id]
    );
    const [updatedCoupon] = await pool.query('SELECT * FROM coupons WHERE id = ?', [req.params.id]);
    if (!updatedCoupon[0]) return res.status(404).json({ error: 'Coupon not found' });
    res.json({
      _id: updatedCoupon[0].id,
      code: updatedCoupon[0].code,
      discount: parseInt(updatedCoupon[0].discount),
      description: updatedCoupon[0].description,
      image: getImageUrl(updatedCoupon[0].image),
      itemCategory: updatedCoupon[0].item_category,
      minQuantity: parseInt(updatedCoupon[0].min_quantity) || null,
      isSpecial: updatedCoupon[0].is_special
    });
  } catch (error) {
    console.error('Error updating coupon:', error.stack);
    res.status(500).json({ error: 'Failed to update coupon' });
  }
});

app.delete('/api/coupons/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const [result] = await pool.query('DELETE FROM coupons WHERE id = ?', [req.params.id]);
    if (result.affectedRows === 0) return res.status(404).json({ error: 'Coupon not found' });
    res.json({ message: 'Coupon deleted' });
  } catch (error) {
    console.error('Error deleting coupon:', error.stack);
    res.status(500).json({ error: 'Failed to delete coupon' });
  }
});

app.post('/api/coupons/validate', authenticateToken, async (req, res) => {
  const { couponCode } = req.body;
  if (!couponCode) return res.status(400).json({ error: 'Coupon code required' });
  try {
    const [result] = await pool.query('SELECT * FROM coupons WHERE code = ?', [couponCode]);
    if (!result[0]) return res.status(404).json({ error: 'Invalid coupon' });
    res.json({
      _id: result[0].id,
      code: result[0].code,
      discount: parseInt(result[0].discount),
      description: result[0].description,
      image: getImageUrl(result[0].image),
      itemCategory: result[0].item_category,
      minQuantity: parseInt(result[0].min_quantity || 0),
      isSpecial: result[0].is_special
    });
  } catch (error) {
    console.error('Error validating coupon:', error.stack);
    res.status(500).json({ error: 'Failed to validate coupon' });
  }
});

// Contact Routes
app.post('/api/contact', authenticateToken, async (req, res) => {
  const { subject, message } = req.body;
  if (!subject || !message) return res.status(400).json({ error: 'Subject and message required' });
  try {
    const [user] = await pool.query('SELECT name, email FROM users WHERE id = ?', [req.user.id]);
    if (!user[0]) return res.status(404).json({ error: 'User not found' });
    const [result] = await pool.query(
      'INSERT INTO contact_messages (user_id, name, email, subject, message) VALUES (?, ?, ?, ?, ?)',
      [req.user.id, user[0].name, user[0].email, subject, message]
    );
    const [newMessage] = await pool.query('SELECT * FROM contact_messages WHERE id = ?', [result.insertId]);
    await transporter.sendMail({
      from: `"Delicute" <${EMAIL_USER}>`,
      to: user[0].email,
      subject: 'Your Message to Delicute',
      text: `Thank you for your message: ${message}`,
      html: `<p>Thank you for your message: <strong>${sanitizeHTML(message)}</strong></p>`
    });
    res.status(201).json({
      _id: newMessage[0].id,
      userId: newMessage[0].user_id,
      name: newMessage[0].name,
      email: newMessage[0].email,
      subject: newMessage[0].subject,
      message: newMessage[0].message,
      status: newMessage[0].status,
      created_at: newMessage[0].created_at
    });
  } catch (error) {
    console.error('Error adding message:', error.stack);
    res.status(500).json({ error: 'Failed to add message' });
  }
});

app.get('/api/contact', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const [result] = await pool.query('SELECT * FROM contact_messages ORDER BY created_at DESC');
    res.json(result.map(item => ({
      _id: item.id,
      userId: item.user_id,
      name: item.name,
      email: item.email,
      subject: item.subject,
      message: item.message,
      status: item.status,
      created_at: item.created_at
    })));
  } catch (error) {
    console.error('Error fetching contacts:', error.stack);
    res.status(500).json({ error: 'Failed to fetch contacts' });
  }
});

app.get('/api/contact/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const [result] = await pool.query('SELECT * FROM contact_messages WHERE id = ?', [req.params.id]);
    if (!result[0]) return res.status(404).json({ error: 'Message not found' });
    res.json({
      _id: result[0].id,
      userId: result[0].user_id,
      name: result[0].name,
      email: result[0].email,
      subject: result[0].subject,
      message: result[0].message,
      status: result[0].status,
      created_at: result[0].created_at
    });
  } catch (error) {
    console.error('Error fetching contact:', error.stack);
    res.status(500).json({ error: 'Failed to fetch contact' });
  }
});

app.post('/api/contact/:id/reply', authenticateToken, requireAdmin, async (req, res) => {
  const { reply, subject } = req.body;
  if (!reply || !subject) return res.status(400).json({ error: 'Subject and reply required' });
  try {
    const [message] = await pool.query('SELECT email FROM contact_messages WHERE id = ?', [req.params.id]);
    if (!message[0]) return res.status(404).json({ error: 'Message not found' });
    await transporter.sendMail({
      from: `"Delicute Reply" <${EMAIL_USER}>`,
      to: message[0].email,
      subject: subject,
      text: reply,
      html: `<p>${sanitizeHTML(reply)}</p>`
    });
    await pool.query('UPDATE contact_messages SET status = ? WHERE id = ?', ['Replied', req.params.id]);
    res.json({ message: 'Reply sent' });
  } catch (error) {
    console.error('Error sending reply:', error.stack);
    res.status(500).json({ error: 'Failed to send reply' });
  }
});

app.delete('/api/contact/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const [result] = await pool.query('DELETE FROM contact_messages WHERE id = ?', [req.params.id]);
    if (result.affectedRows === 0) return res.status(404).json({ error: 'Message not found' });
    res.json({ message: 'Message deleted' });
  } catch (error) {
    console.error('Error deleting contact:', error.stack);
    res.status(500).json({ error: 'Failed to delete contact' });
  }
});

// Address Routes
app.get('/api/addresses', authenticateToken, async (req, res) => {
  try {
    const [result] = await pool.query('SELECT * FROM addresses WHERE user_id = ? ORDER BY created_at DESC', [req.user.id]);
    res.json(result.map(address => ({
      _id: address.id,
      fullName: address.full_name,
      mobileNumber: address.mobile_number,
      houseFlatNo: address.house_flat_no,
      floorNo: address.floor_no,
      address: address.address,
      landmark: address.landmark,
      createdAt: address.created_at
    })));
  } catch (error) {
    console.error('Error fetching addresses:', error.stack);
    res.status(500).json({ error: 'Failed to fetch addresses' });
  }
});

app.post('/api/addresses', authenticateToken, async (req, res) => {
  const { fullName, mobileNumber, houseFlatNo, floorNo, address, landmark } = req.body;
  const validation = validateInput({ fullName, mobileNumber, houseFlatNo, address }, ['fullName', 'mobileNumber', 'houseFlatNo', 'address']);
  if (!validation.valid) return res.status(400).json({ error: validation.error });
  if (!/^\d{10}$/.test(mobileNumber)) return res.status(400).json({ error: 'Mobile number must be 10 digits' });
  try {
    const [result] = await pool.query(
      'INSERT INTO addresses (user_id, full_name, mobile_number, house_flat_no, floor_no, address, landmark) VALUES (?, ?, ?, ?, ?, ?, ?)',
      [req.user.id, fullName, mobileNumber, houseFlatNo, floorNo || null, address, landmark || null]
    );
    const [newAddress] = await pool.query('SELECT * FROM addresses WHERE id = ?', [result.insertId]);
    res.status(201).json({
      _id: newAddress[0].id,
      fullName: newAddress[0].full_name,
      mobileNumber: newAddress[0].mobile_number,
      houseFlatNo: newAddress[0].house_flat_no,
      floorNo: newAddress[0].floor_no,
      address: newAddress[0].address,
      landmark: newAddress[0].landmark,
      createdAt: newAddress[0].created_at
    });
  } catch (error) {
    console.error('Error creating address:', error.stack);
    res.status(500).json({ error: 'Failed to create address' });
  }
});

app.put('/api/addresses/:id', authenticateToken, async (req, res) => {
  const { fullName, mobileNumber, houseFlatNo, floorNo, address, landmark } = req.body;
  const validation = validateInput({ fullName, mobileNumber, houseFlatNo, address }, ['fullName', 'mobileNumber', 'houseFlatNo', 'address']);
  if (!validation.valid) return res.status(400).json({ error: validation.error });
  if (!/^\d{10}$/.test(mobileNumber)) return res.status(400).json({ error: 'Mobile number must be 10 digits' });
  try {
    const [result] = await pool.query(
      'UPDATE addresses SET full_name = ?, mobile_number = ?, house_flat_no = ?, floor_no = ?, address = ?, landmark = ? WHERE id = ? AND user_id = ?',
      [fullName, mobileNumber, houseFlatNo, floorNo || null, address, landmark || null, req.params.id, req.user.id]
    );
    if (result.affectedRows === 0) return res.status(404).json({ error: 'Address not found or unauthorized' });
    const [updatedAddress] = await pool.query('SELECT * FROM addresses WHERE id = ?', [req.params.id]);
    res.json({
      _id: updatedAddress[0].id,
      fullName: updatedAddress[0].full_name,
      mobileNumber: updatedAddress[0].mobile_number,
      houseFlatNo: updatedAddress[0].house_flat_no,
      floorNo: updatedAddress[0].floor_no,
      address: updatedAddress[0].address,
      landmark: updatedAddress[0].landmark,
      createdAt: updatedAddress[0].created_at
    });
  } catch (error) {
    console.error('Error updating address:', error.stack);
    res.status(500).json({ error: 'Failed to update address' });
  }
});

app.delete('/api/addresses/:id', authenticateToken, async (req, res) => {
  try {
    const [result] = await pool.query('DELETE FROM addresses WHERE id = ? AND user_id = ?', [req.params.id, req.user.id]);
    if (result.affectedRows === 0) return res.status(404).json({ error: 'Address not found or unauthorized' });
    res.json({ message: 'Address deleted successfully' });
  } catch (error) {
    console.error('Error deleting address:', error.stack);
    res.status(500).json({ error: 'Failed to delete address' });
  }
});

// Order Routes
app.post('/api/orders', authenticateToken, async (req, res) => {
  const { items, addressId, coupon } = req.body;
  const paymentMethod = 'cod';
  const validation = validateInput({ items, addressId }, ['items', 'addressId']);
  if (!validation.valid) return res.status(400).json({ error: validation.error });

  try {
    const [address] = await pool.query('SELECT * FROM addresses WHERE id = ? AND user_id = ?', [addressId, req.user.id]);
    if (!address[0]) return res.status(404).json({ error: 'Address not found' });

    const itemIds = items.map(item => item.itemId);
    const [menuItems] = await pool.query('SELECT id, price, category, name FROM menu_items WHERE id IN (?)', [itemIds]);
    let subtotal = 0;
    const orderItems = items.map(item => {
      const menuItem = menuItems.find(mi => mi.id === parseInt(item.itemId));
      if (!menuItem) throw new Error(`Item ${item.itemId} not found`);
      subtotal += menuItem.price * item.quantity;
      return {
        itemId: item.itemId,
        name: menuItem.name,
        quantity: item.quantity,
        price: parseFloat(menuItem.price),
        category: menuItem.category
      };
    });

    let discount = 0;
    let couponCode = null;
    if (coupon) {
      const [couponResult] = await pool.query('SELECT * FROM coupons WHERE code = ?', [coupon]);
      if (!couponResult[0]) return res.status(400).json({ error: 'Invalid coupon' });
      const coupon = couponResult[0];
      const eligibleItems = orderItems.filter(item => !coupon.item_category || item.category === coupon.item_category);
      const eligibleQuantity = eligibleItems.reduce((sum, item) => sum + item.quantity, 0);
      if (!coupon.min_quantity || eligibleQuantity >= coupon.min_quantity) {
        discount = eligibleItems.reduce((sum, item) => sum + (item.price * item.quantity * coupon.discount / 100), 0);
        couponCode = coupon.code;
      } else {
        return res.status(400).json({ error: `Coupon requires at least ${coupon.min_quantity} ${coupon.item_category || 'items'}` });
      }
    }

    const total = subtotal - discount;
    const estimatedDelivery = new Date(Date.now() + 30 * 60 * 1000);
    const orderId = `ORD_${Date.now()}_${Math.floor(Math.random() * 1000)}`;

    const [result] = await pool.query(
      'INSERT INTO orders (user_id, address_id, items, total, discount, coupon, payment_method, estimated_delivery, order_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)',
      [req.user.id, addressId, JSON.stringify(orderItems), total, discount, couponCode, paymentMethod, estimatedDelivery, orderId]
    );

    await pool.query('UPDATE orders SET status = ?, payment_status = ? WHERE id = ?', ['Confirmed', 'Pending', result.insertId]);
    const [newOrder] = await pool.query('SELECT * FROM orders WHERE id = ?', [result.insertId]);

    const orderResponse = {
      _id: newOrder[0].id,
      orderId: newOrder[0].order_id,
      userId: newOrder[0].user_id,
      addressId: newOrder[0].address_id,
      address: {
        _id: address[0].id,
        fullName: address[0].full_name,
        mobileNumber: address[0].mobile_number,
        houseFlatNo: address[0].house_flat_no,
        floorNo: address[0].floor_no,
        address: address[0].address,
        landmark: address[0].landmark
      },
      items: JSON.parse(newOrder[0].items),
      total: parseFloat(newOrder[0].total),
      status: newOrder[0].status,
      paymentStatus: newOrder[0].payment_status,
      paymentMethod: newOrder[0].payment_method,
      coupon: newOrder[0].coupon,
      discount: parseFloat(newOrder[0].discount),
      estimatedDelivery: newOrder[0].estimated_delivery,
      createdAt: newOrder[0].created_at
    };

    res.json(orderResponse);
  } catch (error) {
    console.error('Error creating order:', error.stack);
    res.status(500).json({ error: 'Failed to create order' });
  }
});

app.get('/api/orders', authenticateToken, async (req, res) => {
  try {
    const [result] = await pool.query(
      'SELECT * FROM orders WHERE user_id = ? AND status NOT IN (?, ?)',
      [req.user.id, 'Delivered', 'Cancelled']
    );

    const orders = await Promise.all(
      result.map(async (order) => {
        const [address] = await pool.query('SELECT * FROM addresses WHERE id = ?', [order.address_id]);
        return {
          _id: order.id,
          orderId: order.order_id,
          userId: order.user_id,
          addressId: order.address_id,
          address: address[0] ? {
            _id: address[0].id,
            fullName: address[0].full_name,
            mobileNumber: address[0].mobile_number,
            houseFlatNo: address[0].house_flat_no,
            floorNo: address[0].floor_no,
            address: address[0].address,
            landmark: address[0].landmark
          } : null,
          items: JSON.parse(order.items),
          total: parseFloat(order.total),
          status: order.status,
          paymentStatus: order.payment_status,
          paymentMethod: order.payment_method,
          coupon: order.coupon,
          discount: parseFloat(order.discount),
          estimatedDelivery: order.estimated_delivery,
          createdAt: order.created_at
        };
      })
    );

    res.json(orders);
  } catch (error) {
    console.error('Error fetching active orders:', error.stack);
    res.status(500).json({ error: 'Failed to fetch active orders' });
  }
});

app.get('/api/orders/history', authenticateToken, async (req, res) => {
  try {
    const [result] = await pool.query('SELECT * FROM orders WHERE user_id = ? ORDER BY created_at DESC', [req.user.id]);
    const orders = await Promise.all(result.map(async (order) => {
      const [address] = await pool.query('SELECT * FROM addresses WHERE id = ?', [order.address_id]);
      return {
        _id: order.id,
        orderId: order.order_id,
        userId: order.user_id,
        addressId: order.address_id,
        address: address[0] ? {
          _id: address[0].id,
          fullName: address[0].full_name,
          mobileNumber: address[0].mobile_number,
          houseFlatNo: address[0].house_flat_no,
          floorNo: address[0].floor_no,
          address: address[0].address,
          landmark: address[0].landmark
        } : null,
        items: JSON.parse(order.items),
        total: parseFloat(order.total),
        status: order.status,
        paymentStatus: order.payment_status,
        paymentMethod: order.payment_method,
        coupon: order.coupon,
        discount: parseFloat(order.discount),
        estimatedDelivery: order.estimated_delivery,
        createdAt: order.created_at
      };
    }));
    res.json(orders);
  } catch (error) {
    console.error('Error fetching order history:', error.stack);
    res.status(500).json({ error: 'Failed to fetch order history' });
  }
});

app.delete('/api/orders/history', authenticateToken, async (req, res) => {
  try {
      await pool.query('DELETE FROM orders WHERE user_id = ? AND status IN (?, ?)', [req.user.id, 'Delivered', 'Cancelled']);
      res.json({ message: 'Order history cleared successfully' });
    } catch (error) {
      console.error('Error clearing order history:', error.stack);
      res.status(500).json({ error: 'Failed to clear order history' });
    }
  });

app.post('/api/orders/:id/cancel', authenticateToken, async (req, res) => {
  const { reason } = req.body;
  if (!reason) return res.status(400).json({ error: 'Cancellation reason required' });
  try {
      const [order] = await pool.query('SELECT * FROM orders WHERE id = ? AND user_id = ?', [req.params.id, req.user.id]);
      if (!order[0]) return res.status(404).json({ error: 'Order not found or unauthorized' });
      if (order[0].status !== 'Pending' && order[0].status !== 'Confirmed') return res.status(400).json({ error: 'Cannot cancel order that is not pending or confirmed' });
      await pool.query('UPDATE orders SET status = ?, cancellation_reason = ? WHERE id = ?', ['Cancelled', reason, req.params.id]);
      const [user] = await pool.query('SELECT email FROM users WHERE id = ?', [req.user.id]);
      await transporter.sendMail({
        from: `"Delicute" <${EMAIL_USER}>`,
        to: user[0].email,
        subject: 'Delicute Order Cancellation Confirmation',
        text: `Your order #${order[0].order_id} has been cancelled. Reason: ${reason}`,
        html: `<p>Your order #${order[0].order_id} has been cancelled successfully. Reason: <strong>${sanitizeHTML(reason)}</strong></p>`
      });
      res.json({ message: 'Order successfully cancelled successfully' });
    } catch (error) {
      console.error('Error cancelling order:', error.stack);
      res.status(500).json({ error: 'Failed to cancel order' });
    }
  });

app.get('/api/orders/all', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const [result] = await pool.query('SELECT * FROM orders ORDER BY created_at DESC');
    const orders = await Promise.all(result.map(async (order) => {
      const [address] = await pool.query('SELECT * FROM addresses WHERE id = ?', [order.address_id]);
      return {
        _id: order.id,
        orderId: order.order_id,
        userId: order.user_id,
        addressId: order.address_id,
        address: address[0] ? {
          _id: address[0].id,
          fullName: address[0].full_name,
          mobileNumber: address[0].mobile_number,
          houseFlatNo: address[0].house_flat_no,
          floorNo: address[0].floor_no,
          address: address[0].address,
          landmark: address[0].landmark
        } : null,
        items: JSON.parse(order.items),
        total: parseFloat(order.total),
        status: order.status,
        paymentStatus: order.payment_status,
        paymentMethod: order.payment_method,
        coupon: order.coupon,
        discount: parseFloat(order.discount),
        estimatedDelivery: order.estimated_delivery,
        createdAt: order.created_at
      };
    }));
    res.json({ orders });
    } catch (error) {
      console.error('Error fetching orders:', error.stack);
      res.status(500).json({ error: 'Failed to fetch orders' });
    }
  });

app.get('/api/orders/:id', authenticateToken, async (req, res) => {
  try {
      const [order] = await pool.query('SELECT * FROM orders WHERE id = ? AND user_id = ?', [req.params.id, req.user.id]);
      if (!order[0]) return res.status(404).json({ error: 'Order not found or unauthorized' });
      const [address] = await pool.query('SELECT * FROM addresses WHERE id = ?', [order[0].address_id]);
      res.json({
        _id: order[0].id,
        orderId: order[0].order_id,
        userId: order[0].user_id,
        addressId: order[0].address_id,
        address: address[0] ? {
            _id: address[0].id,
            fullName: address[0].full_name,
            mobileNumber: address[0].mobile_number,
            houseFlatNo: address[0].house_flat_no,
            floorNo: address[0].floor_no,
            address: address[0].address,
            landmark: address[0].landmark
          } : null,
          items: JSON.parse(order[0].items),
          total: parseFloat(order[0].total),
          status: order[0].status,
          paymentStatus: order[0].payment_status,
          paymentMethod: order[0].payment_method,
          coupon: order[0].coupon,
          discount: parseFloat(order[0].discount),
          estimatedDelivery: order[0].estimated_delivery,
          createdAt: order[0].created_at
      });
    } catch (error) {
      console.error('Error fetching order:', error.stack);
      res.status(500).json({ error: 'Failed to fetch order' });
    }
  });

app.put('/api/orders/:id', authenticateToken, requireAdmin, async (req, res) => {
  const { status } = req.body;
  if (!status || !['Pending', 'Confirmed', 'Delivered', 'Cancelled'].includes(status)) {
    return res.status(400).json({ error: 'Invalid status' });
  }
  try {
    await pool.query('UPDATE orders SET status = ? WHERE id = ?', [status, req.params.id]);
    const [order] = await pool.query('SELECT * FROM orders WHERE id = ?', [req.params.id]);
    if (!order[0]) return res.status(404).json({ error: 'Order not found' });
    const [address] = await pool.query('SELECT * FROM addresses WHERE id = ?', [order[0].address_id]);
    res.json({
      _id: order[0].id,
      orderId: order[0].order_id,
      userId: order[0].user_id,
      addressId: order[0].address_id,
      address: address[0] ? {
        _id: address[0].id,
        fullName: address[0].full_name,
        mobileNumber: address[0].mobile_number,
        houseFlatNo: address[0].house_flat_no,
        floorNo: address[0].floor_no,
        address: address[0].address,
        landmark: address[0].landmark
      } : null,
      items: JSON.parse(order[0].items),
      total: parseFloat(order[0].total),
      status: order[0].status,
      paymentStatus: order[0].payment_status,
      paymentMethod: order[0].payment_method,
      coupon: order[0].coupon,
      discount: parseFloat(order[0].discount),
      estimatedDelivery: order[0].estimated_delivery,
      createdAt: order[0].created_at
    });
  } catch (error) {
    console.error('Error updating order:', error.stack);
    res.status(500).json({ error: 'Failed to update order' });
  }
});

app.delete('/api/orders/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const [result] = await pool.query('DELETE FROM orders WHERE id = ?', [req.params.id]);
    if (result.affectedRows === 0) return res.status(404).json({ error: 'Order not found' });
    res.json({ message: 'Order deleted successfully' });
  } catch (error) {
    console.error('Error deleting order:', error.stack);
    res.status(500).json({ error: 'Failed to delete order' });
  }
});

// User Routes
app.get('/api/users', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const [users] = await pool.query('SELECT id, name, email, phone_number, is_blocked, profile_image FROM users WHERE is_admin = ?', [false]);
    res.json(users.map(user => ({
      _id: user.id,
      name: user.name,
      email: user.email,
      phone: user.phone,
      status: user.is_blocked ? 'Blocked' : 'Active',
      profileImage: getImageUrl(user.profile_image)
    })));
  } catch (error) {
    console.error('Error fetching users:', error.stack);
    res.status(500).json({ error: 'Failed to fetch users' });
  }
});

app.get('/api/users/:id', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const [user] = await pool.query('SELECT id, name, email, phone, is_blocked, profile_image FROM users WHERE id = ? AND is_admin = ?', [parseInt(req.params.id), false]);
    if (!user[0]) return res.status(404).json({ error: 'User not found' });
    const [orders] = await pool.query('SELECT id, total, status, created_at, order_id FROM orders WHERE user_id = ?', [req.params.id]);
    res.json({
      _id: user[0].id,
      name: user[0].name,
      email: user.email,
      phone: user[0].phone,
      status: user[0].is_blocked ? 'Blocked' : 'Active',
      profileImage: getImageUrl(user[0].profile_image),
      orders: orders.map(order => ({
        _id: order.id,
        orderId: order.order_id,
        total: parseFloat(order.total),
        status: order.status,
        createdAt: order.created_at
      }))
    });
  } catch (error) {
    console.error('Error fetching user:', error.stack);
    res.status(500).json({ error: 'Failed to fetch user' });
  }
});

app.put('/api/users/:id/status', authenticateToken, requireAdmin, async (req, res) => {
  const { status } = req.body;
  if (!status || !['Active', 'Blocked'].includes(status)) {
    return res.status(400).json({ error: 'Invalid status' });
  }
  try {
    const isBlocked = status === 'Blocked' ? true : false;
    await pool.query('UPDATE users SET is_blocked = ? WHERE id = ?', [isBlocked, req.params.id]);
    res.json({ message: `User ${status.toLowerCase()} successfully` });
  } catch (error) {
    console.error('Error updating user status:', error.stack);
    res.status(500).json({ error: 'Failed to update user status' });
  }
});

// Restaurant Status Routes
app.get('/api/restaurant/status', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const [status] = await pool.query('SELECT is_open FROM restaurant_status WHERE id = ?', [1]);
    res.json({ isOpen: status[0] ? status[0].is_open : false });
  } catch (error) {
    console.error('Error fetching restaurant status:', error.stack);
    res.status(500).json({ error: 'Failed to fetch restaurant status' });
  }
});

app.put('/api/restaurant/status', authenticateToken, requireAdmin, async (req, res) => {
  const { isOpen } = req.body;
  if (typeof isOpen !== 'boolean') {
    return res.status(400).json({ error: 'Invalid status' });
  }
  try {
    await pool.query('UPDATE restaurant_status SET is_open = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?', [isOpen, 1]);
    res.json({ isOpen });
  } catch (error) {
    console.error('Error updating restaurant status:', error.stack);
    res.status(500).json({ error: 'Failed to update restaurant status' });
  }
});

// Error Handling Middleware
app.use((err, req, res, next) => {
  console.error('Server error:', err.stack);
  if (err instanceof multer.MulterError) {
    return res.status(400).json({ error: `File upload error: ${err.message}` });
  }
  res.status(500).json({ error: 'Something went wrong', details: process.env.NODE_ENV === 'development' ? err.message : undefined });
});

// Server Startup
async function startServer() {
  try {
    await initializeDatabase();
    app.listen(PORT, () => {
      console.log(`✅ Server running on port ${PORT}`);
    });
  } catch (error) {
    console.error('❌ Failed to start server:', error.stack);
    process.exit(1);
  }
}

startServer();